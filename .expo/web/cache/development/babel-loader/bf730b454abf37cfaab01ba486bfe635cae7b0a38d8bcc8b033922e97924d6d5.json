{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nvar TextExtraction = function () {\n  function TextExtraction(text, patterns) {\n    _classCallCheck(this, TextExtraction);\n    this.text = text;\n    this.patterns = patterns || [];\n  }\n  _createClass(TextExtraction, [{\n    key: \"parse\",\n    value: function parse() {\n      var _this = this;\n      var parsedTexts = [{\n        children: this.text\n      }];\n      this.patterns.forEach(function (pattern) {\n        var newParts = [];\n        var tmp = pattern.nonExhaustiveModeMaxMatchCount || 0;\n        var numberOfMatchesPermitted = Math.min(Math.max(Number.isInteger(tmp) ? tmp : 0, 0) || Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);\n        var currentMatches = 0;\n        parsedTexts.forEach(function (parsedText) {\n          if (parsedText._matched) {\n            newParts.push(parsedText);\n            return;\n          }\n          var parts = [];\n          var textLeft = parsedText.children;\n          var indexOfMatchedString = 0;\n          var matches;\n          pattern.pattern.lastIndex = 0;\n          while (textLeft && (matches = pattern.pattern.exec(textLeft))) {\n            var previousText = textLeft.substr(0, matches.index);\n            indexOfMatchedString = matches.index;\n            if (++currentMatches > numberOfMatchesPermitted) {\n              break;\n            }\n            parts.push({\n              children: previousText\n            });\n            parts.push(_this.getMatchedPart(pattern, matches[0], matches, indexOfMatchedString));\n            textLeft = textLeft.substr(matches.index + matches[0].length);\n            indexOfMatchedString += matches[0].length - 1;\n            pattern.pattern.lastIndex = 0;\n          }\n          parts.push({\n            children: textLeft\n          });\n          newParts.push.apply(newParts, parts);\n        });\n        parsedTexts = newParts;\n      });\n      parsedTexts.forEach(function (parsedText) {\n        return delete parsedText._matched;\n      });\n      return parsedTexts.filter(function (t) {\n        return !!t.children;\n      });\n    }\n  }, {\n    key: \"getMatchedPart\",\n    value: function getMatchedPart(matchedPattern, text, matches, index) {\n      var props = {};\n      Object.keys(matchedPattern).forEach(function (key) {\n        if (key === 'pattern' || key === 'renderText' || key === 'nonExhaustiveModeMaxMatchCount') {\n          return;\n        }\n        if (typeof matchedPattern[key] === 'function') {\n          props[key] = function () {\n            return matchedPattern[key](text, index);\n          };\n        } else {\n          props[key] = matchedPattern[key];\n        }\n      });\n      var children = text;\n      if (matchedPattern.renderText && typeof matchedPattern.renderText === 'function') {\n        children = matchedPattern.renderText(text, matches);\n      }\n      return _objectSpread(_objectSpread({}, props), {}, {\n        children: children,\n        _matched: true\n      });\n    }\n  }]);\n  return TextExtraction;\n}();\nexport default TextExtraction;","map":{"version":3,"names":["TextExtraction","text","patterns","_classCallCheck","_createClass","key","value","parse","_this","parsedTexts","children","forEach","pattern","newParts","tmp","nonExhaustiveModeMaxMatchCount","numberOfMatchesPermitted","Math","min","max","Number","isInteger","POSITIVE_INFINITY","currentMatches","parsedText","_matched","push","parts","textLeft","indexOfMatchedString","matches","lastIndex","exec","previousText","substr","index","getMatchedPart","length","apply","filter","t","matchedPattern","props","Object","keys","renderText","_objectSpread"],"sources":["C:/Users/erick_ribeiro-souza/Desktop/s.a 2/sa.ReactNative2semestre-1/node_modules/react-native-parsed-text/src/lib/TextExtraction.js"],"sourcesContent":["/**\n * If you want to provide a custom regexp, this is the configuration to use.\n * -- For historical reasons, all regexps are processed as if they have the global flag set.\n * -- Use the nonExhaustiveModeMaxMatchCount property to match a limited number of matches.\n * Note: any additional keys/props are permitted, and will be returned as-is!\n * @typedef {Object} CustomParseShape\n * @property {RegExp} pattern\n * @property {number} [nonExhaustiveModeMaxMatchCount] Enables \"non-exhaustive mode\", where you can limit how many matches are found. -- Must be a positive integer or Infinity matches are permitted\n * @property {Function} [renderText] arbitrary function to rewrite the matched string into something else\n * @property {Function} [onPress]\n * @property {Function} [onLongPress]\n */\n/**\n * Class to encapsulate the business logic of converting text into matches & props\n */\nclass TextExtraction {\n  /**\n   * @param {String} text - Text to be parsed\n   * @param {CustomParseShape[]} patterns - Patterns to be used when parsed,\n   *                                 any extra attributes, will be returned from parse()\n   */\n  constructor(text, patterns) {\n    this.text = text;\n    this.patterns = patterns || [];\n  }\n\n  /**\n   * Returns parts of the text with their own props\n   * @public\n   * @return {Object[]} - props for all the parts of the text\n   */\n  parse() {\n    let parsedTexts = [{ children: this.text }];\n    this.patterns.forEach((pattern) => {\n      let newParts = [];\n\n      const tmp = pattern.nonExhaustiveModeMaxMatchCount || 0;\n      const numberOfMatchesPermitted = Math.min(\n        Math.max(Number.isInteger(tmp) ? tmp : 0, 0) ||\n          Number.POSITIVE_INFINITY,\n        Number.POSITIVE_INFINITY,\n      );\n\n      let currentMatches = 0;\n\n      parsedTexts.forEach((parsedText) => {\n        // Only allow for now one parsing\n        if (parsedText._matched) {\n          newParts.push(parsedText);\n          return;\n        }\n\n        let parts = [];\n        let textLeft = parsedText.children;\n        let indexOfMatchedString = 0;\n\n        /** @type {RegExpExecArray} */\n        let matches;\n        // Global RegExps are stateful, this makes it start at 0 if reused\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec\n        pattern.pattern.lastIndex = 0;\n        while (textLeft && (matches = pattern.pattern.exec(textLeft))) {\n          let previousText = textLeft.substr(0, matches.index);\n          indexOfMatchedString = matches.index;\n\n          if (++currentMatches > numberOfMatchesPermitted) {\n            // Abort if we've exhausted our number of matches\n            break;\n          }\n\n          parts.push({ children: previousText });\n\n          parts.push(\n            this.getMatchedPart(\n              pattern,\n              matches[0],\n              matches,\n              indexOfMatchedString,\n            ),\n          );\n\n          textLeft = textLeft.substr(matches.index + matches[0].length);\n          indexOfMatchedString += matches[0].length - 1;\n          // Global RegExps are stateful, this makes it operate on the \"remainder\" of the string\n          pattern.pattern.lastIndex = 0;\n        }\n\n        parts.push({ children: textLeft });\n\n        newParts.push(...parts);\n      });\n\n      parsedTexts = newParts;\n    });\n\n    // Remove _matched key.\n    parsedTexts.forEach((parsedText) => delete parsedText._matched);\n\n    return parsedTexts.filter((t) => !!t.children);\n  }\n\n  // private\n\n  /**\n   * @protected\n   * @param {ParseShape} matchedPattern - pattern configuration of the pattern used to match the text\n   * @param {String} text - Text matching the pattern\n   * @param {String[]} matches - Result of the RegExp.exec\n   * @param {Integer} index - Index of the matched string in the whole string\n   * @return {Object} props for the matched text\n   */\n  getMatchedPart(matchedPattern, text, matches, index) {\n    let props = {};\n\n    Object.keys(matchedPattern).forEach((key) => {\n      if (\n        key === 'pattern' ||\n        key === 'renderText' ||\n        key === 'nonExhaustiveModeMaxMatchCount'\n      ) {\n        return;\n      }\n\n      if (typeof matchedPattern[key] === 'function') {\n        // Support onPress / onLongPress functions\n        props[key] = () => matchedPattern[key](text, index);\n      } else {\n        // Set a prop with an arbitrary name to the value in the match-config\n        props[key] = matchedPattern[key];\n      }\n    });\n\n    let children = text;\n    if (\n      matchedPattern.renderText &&\n      typeof matchedPattern.renderText === 'function'\n    ) {\n      children = matchedPattern.renderText(text, matches);\n    }\n\n    return {\n      ...props,\n      children: children,\n      _matched: true,\n    };\n  }\n}\n\nexport default TextExtraction;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}